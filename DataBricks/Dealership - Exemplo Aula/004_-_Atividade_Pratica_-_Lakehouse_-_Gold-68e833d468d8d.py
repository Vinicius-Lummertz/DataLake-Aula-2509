# Databricks notebook source
# MAGIC %md
# MAGIC ## df = spark.read.format("delta").table("schema.tabela")
# MAGIC
# MAGIC Gerando um dataframe dos delta lake no container bronze do Azure Data Lake Storage

# COMMAND ----------

# MAGIC %sql
# MAGIC select * from gold.dim_carro

# COMMAND ----------

df_apolice   = spark.read.format("delta").table("silver.apolice")
df_carro     = spark.read.format("delta").table("silver.carro")
df_cliente   = spark.read.format("delta").table("silver.cliente")
df_endereco  = spark.read.format("delta").table("silver.endereco")
df_estado    = spark.read.format("delta").table("silver.estado")
df_marca     = spark.read.format("delta").table("silver.marca")
df_modelo    = spark.read.format("delta").table("silver.modelo")
df_municipio = spark.read.format("delta").table("silver.municipio")
df_regiao    = spark.read.format("delta").table("silver.regiao")
df_sinistro  = spark.read.format("delta").table("silver.sinistro")
df_telefone  = spark.read.format("delta").table("silver.telefone")


# COMMAND ----------

# MAGIC %md
# MAGIC ### Adicionando metadados de data e hora de processamento e nome do arquivo de origem

# COMMAND ----------

# MAGIC %sql
# MAGIC drop table if exists gold.dim_carro

# COMMAND ----------

# MAGIC %sql
# MAGIC create table gold.dim_carro (
# MAGIC   SK_CARRO             bigint generated by default as identity,
# MAGIC   PLACA                varchar(10),
# MAGIC   MARCA                varchar(100),
# MAGIC   MODELO               varchar(100),
# MAGIC   COR                  varchar(10),
# MAGIC   ANO                  int,
# MAGIC   CHASSI               varchar(20)
# MAGIC )
# MAGIC USING DELTA;

# COMMAND ----------

# MAGIC %sql
# MAGIC DESCRIBE TABLE EXTENDED gold.dim_carro

# COMMAND ----------

df_modelo.createOrReplaceTempView("modelo")
df_marca.createOrReplaceTempView("marca")
df_carro.createOrReplaceTempView("carro")

# COMMAND ----------

# MAGIC %sql
# MAGIC
# MAGIC WITH carros_relacional AS (
# MAGIC 	SELECT placa,
# MAGIC 		   nome_marca,
# MAGIC 		   nome_modelo,
# MAGIC 		   cor,
# MAGIC 		   ano,
# MAGIC 		   chassi 
# MAGIC 	  FROM carro c
# MAGIC 		   INNER JOIN modelo mo
# MAGIC 		     ON c.codigo_modelo = mo.codigo_modelo
# MAGIC 		   INNER JOIN marca ma
# MAGIC 		     ON mo.codigo_marca = ma.codigo_marca
# MAGIC )
# MAGIC MERGE INTO
# MAGIC 	gold.dim_carro AS c
# MAGIC USING
# MAGIC 	carros_relacional AS cc
# MAGIC ON c.placa = cc.placa   
# MAGIC
# MAGIC WHEN MATCHED AND (c.marca <> cc.nome_marca OR c.modelo <> cc.nome_modelo OR c.cor <> cc.cor OR c.ano <> cc.ano OR c.chassi <> cc.chassi) THEN
# MAGIC
# MAGIC 	UPDATE SET placa  = cc.placa,
# MAGIC 	           marca  = cc.nome_marca,
# MAGIC 			   modelo = cc.nome_modelo,
# MAGIC 			   cor    = cc.cor,
# MAGIC 			   ano    = cc.ano,
# MAGIC 			   chassi = cc.chassi
# MAGIC
# MAGIC WHEN NOT MATCHED THEN
# MAGIC 	INSERT (placa, marca, modelo, cor, ano, chassi)
# MAGIC 	VALUES (cc.placa, cc.nome_marca, cc.nome_modelo, cc.cor, cc.ano, cc.chassi)
# MAGIC

# COMMAND ----------

# MAGIC %sql
# MAGIC select * from gold.dim_carro

# COMMAND ----------

# MAGIC %sql
# MAGIC drop table if exists gold.dim_tempo

# COMMAND ----------

from pyspark.sql.functions import expr, date_format

# Define o intervalo de datas desejado
data_inicial = "2023-01-01"
data_final = "2026-12-31"

# Calcula o número de dias no intervalo
num_dias = spark.sql(f"SELECT datediff('{data_final}', '{data_inicial}')").collect()[0][0]

# Cria um DataFrame com uma coluna contendo uma sequência de datas
df_calendario = spark.range(0, num_dias + 1) \
    .selectExpr(f"date_add(to_date('{data_inicial}'), CAST(id AS INT)) AS Data")

# Extrai os componentes de data
df_tempo = df_calendario.selectExpr(
    "Data",
    "year(Data) AS Ano",
    "month(Data) AS Mes",
       "(CASE month(Data) \
        WHEN 1 THEN 'JANEIRO' \
        WHEN 2 THEN 'FEVEREIRO' \
        WHEN 3 THEN 'MARCO' \
        WHEN 4 THEN 'ABRIL' \
        WHEN 5 THEN 'MAIO' \
        WHEN 6 THEN 'JUNHO' \
        WHEN 7 THEN 'JULHO' \
        WHEN 8 THEN 'AGOSTO' \
        WHEN 9 THEN 'SETEMBRO' \
        WHEN 10 THEN 'OUTUBRO' \
        WHEN 11 THEN 'NOVEMBRO' \
        WHEN 12 THEN 'DEZEMBRO' \
    END) AS NomeMes",
    "day(Data) AS Dia",
    "(CASE dayofweek(Data) \
        WHEN 1 THEN 'DOMINGO' \
        WHEN 2 THEN 'SEGUNDA-FEIRA' \
        WHEN 3 THEN 'TERCA-FEIRA' \
        WHEN 4 THEN 'QUARTA-FEIRA' \
        WHEN 5 THEN 'QUINTA-FEIRA' \
        WHEN 6 THEN 'SEXTA-FEIRA' \
        WHEN 7 THEN 'SABADO' \
    END) AS NomeDiaSemana",
    "dayofweek(Data) AS NumeroDiaSemana"
)

# Exibe o DataFrame resultante
df_tempo.display()

df_tempo.write.mode('overwrite').saveAsTable("gold.dim_tempo", format="delta")


# COMMAND ----------

# MAGIC %sql
# MAGIC drop table if exists gold.dim_cliente

# COMMAND ----------

# MAGIC %sql
# MAGIC create table gold.dim_cliente (
# MAGIC    SK_CLIENTE           bigint generated by default as identity,
# MAGIC    CODIGO_CLIENTE       int,
# MAGIC    NOME                 varchar(50),
# MAGIC    CPF                  varchar(11),
# MAGIC    SEXO                 char(1),
# MAGIC    DATA_NASCIMENTO      date
# MAGIC )
# MAGIC USING DELTA;
# MAGIC

# COMMAND ----------

df_cliente.createOrReplaceTempView("cliente")

# COMMAND ----------

# MAGIC %sql
# MAGIC --v3a (COM CTE) prevendo atualizacao SCD1
# MAGIC WITH cliente_relacional AS (
# MAGIC 	SELECT codigo_cliente,
# MAGIC 		   nome,
# MAGIC 		   cpf,
# MAGIC 		   sexo,
# MAGIC 		   data_nascimento
# MAGIC 	  FROM cliente
# MAGIC )
# MAGIC MERGE INTO
# MAGIC 	gold.dim_cliente AS d
# MAGIC USING
# MAGIC 	cliente_relacional AS r
# MAGIC ON r.codigo_cliente = d.codigo_cliente   
# MAGIC
# MAGIC WHEN MATCHED AND (r.codigo_cliente <> d.codigo_cliente OR r.nome <> d.nome OR r.cpf <> d.cpf OR r.sexo <> d.sexo OR r.data_nascimento <> d.data_nascimento) THEN
# MAGIC
# MAGIC 	UPDATE SET codigo_cliente    = r.codigo_cliente,
# MAGIC 	           nome          = r.nome,
# MAGIC 			   cpf           = r.cpf,
# MAGIC 			   sexo          = r.sexo,
# MAGIC 			   data_nascimento = r.data_nascimento
# MAGIC
# MAGIC WHEN NOT MATCHED THEN
# MAGIC
# MAGIC 	INSERT (codigo_cliente, nome, cpf, sexo, data_nascimento)
# MAGIC 	VALUES (r.codigo_cliente, r.nome, r.cpf, r.sexo, r.data_nascimento)
# MAGIC
# MAGIC

# COMMAND ----------

# MAGIC %sql
# MAGIC select * from gold.dim_cliente

# COMMAND ----------

# MAGIC %sql
# MAGIC drop table if exists gold.dim_localidade

# COMMAND ----------

# MAGIC %sql
# MAGIC
# MAGIC create table gold.dim_localidade (
# MAGIC    SK_LOCALIDADE        bigint generated by default as identity,
# MAGIC    CODIGO_MUNICIPIO     int,
# MAGIC    NOME_MUNICIPIO       varchar(100),
# MAGIC    NOME_ESTADO          varchar(100),
# MAGIC    NOME_REGIAO          varchar(100)
# MAGIC )
# MAGIC USING DELTA

# COMMAND ----------

df_municipio.createOrReplaceTempView("municipio")
df_estado.createOrReplaceTempView("estado")
df_regiao.createOrReplaceTempView("regiao")

# COMMAND ----------

# MAGIC %sql
# MAGIC --v3a (COM CTE) prevendo atualizacao SCD1
# MAGIC WITH localidade_relacional AS (
# MAGIC 	SELECT codigo_municipio,
# MAGIC 		   nome_municipio,
# MAGIC 		   nome_estado,
# MAGIC 		   nome_regiao
# MAGIC 	  FROM municipio m
# MAGIC 		   INNER JOIN estado e
# MAGIC 		     ON m.codigo_estado = e.codigo_estado
# MAGIC 		   INNER JOIN regiao r
# MAGIC 		     ON e.codigo_regiao = r.codigo_regiao
# MAGIC )
# MAGIC MERGE INTO
# MAGIC 	gold.dim_localidade AS d
# MAGIC USING
# MAGIC 	localidade_relacional AS r
# MAGIC
# MAGIC ON r.codigo_municipio = d.codigo_municipio
# MAGIC
# MAGIC WHEN MATCHED AND (r.codigo_municipio <> d.codigo_municipio OR r.nome_municipio <> d.nome_municipio OR r.nome_estado <> d.nome_estado OR r.nome_regiao <> d.nome_regiao) THEN
# MAGIC 	UPDATE SET codigo_municipio = r.codigo_municipio,
# MAGIC 		       nome_municipio = r.nome_municipio,
# MAGIC 			   nome_estado    = r.nome_estado,
# MAGIC 		       nome_regiao    = r.nome_regiao
# MAGIC
# MAGIC WHEN NOT MATCHED THEN
# MAGIC 	INSERT (codigo_municipio, nome_municipio, nome_estado, nome_regiao)
# MAGIC 	VALUES (r.codigo_municipio, r.nome_municipio, r.nome_estado, r.nome_regiao)
# MAGIC

# COMMAND ----------

# MAGIC %sql
# MAGIC select * from gold.dim_localidade

# COMMAND ----------

# MAGIC %sql
# MAGIC drop table if exists gold.fato_sinistro

# COMMAND ----------

# MAGIC %sql
# MAGIC create table gold.fato_sinistro (
# MAGIC    FK_TEMPO             date,
# MAGIC    FK_LOCALIDADE        int,
# MAGIC    FK_CARRO             int,
# MAGIC    FK_CLIENTE           int,
# MAGIC    QTDE_SINISTRO        int
# MAGIC )
# MAGIC USING DELTA;

# COMMAND ----------

df_apolice.createOrReplaceTempView("apolice")
df_sinistro.createOrReplaceTempView("sinistro")

# COMMAND ----------

# MAGIC %sql
# MAGIC with apolice_cliente as (
# MAGIC 	select a.codigo_cliente, placa from apolice a inner join cliente c on a.codigo_cliente = c.codigo_cliente
# MAGIC )
# MAGIC insert into gold.fato_sinistro
# MAGIC select data,
# MAGIC        sk_localidade,
# MAGIC 	   sk_carro,
# MAGIC 	   sk_cliente,
# MAGIC 	   count(1) as qtde_sinistro
# MAGIC from sinistro r
# MAGIC        inner join gold.dim_carro dcar
# MAGIC 	     on r.placa = dcar.placa
# MAGIC 	   inner join apolice_cliente ac
# MAGIC 	     on ac.placa = r.placa
# MAGIC 	   inner join gold.dim_cliente dcli
# MAGIC 	     on ac.codigo_cliente = dcli.codigo_cliente
# MAGIC 	   inner join gold.dim_localidade dloc
# MAGIC 	     on r.local_sinistro = dloc.codigo_municipio
# MAGIC 	   inner join gold.dim_tempo dtem
# MAGIC 	     on r.data_sinistro = dtem.data
# MAGIC group by data,
# MAGIC        sk_localidade,
# MAGIC 	   sk_carro,
# MAGIC 	   sk_cliente

# COMMAND ----------

# MAGIC %sql
# MAGIC select * from gold.fato_sinistro